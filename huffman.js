// node class is the basic structure
// of each node present in the Huffman - tree.
class NodoHuffman {
    constructor() {
        this.frecuencia = 0;
        this.c = '';
        this.izquierda = this.right = null;
    }
}

// recursive function to print the
// huffman-code through the tree traversal.
// Here s is the huffman - code generated.
function printCode(root, s) {
    // base case; if the izquierda and right are null
    // then its a leaf node and we print
    // the code s generated by traversing the tree.
    if (root.izquierda == null &&
        root.right == null &&
        (root.c).toLowerCase() != (root.c).toUpperCase()) {

        // c is the character in the node
        document.write(root.c + ":" + s + "<br>");

        return;
    }

    // if we go to izquierda then add "0" to the code.
    // if we go to the right add"1" to the code.

    // recursive calls for izquierda and
    // right sub-tree of the generated tree.
    printCode(root.izquierda, s + "0");
    printCode(root.right, s + "1");
}

// main function  
// number of characters.
let n = 6;
let charArray = ['a', 'b', 'c', 'd', 'e', 'f'];
let charfreq = [5, 9, 12, 13, 16, 45];

// creating a priority queue q.
// makes a min-priority queue(min-heap).
let q = [];

for (let i = 0; i < n; i++) {

    // creating a Huffman node object
    // and add it to the priority queue.
    let hn = new NodoHuffman();

    hn.c = charArray[i];
    hn.frecuencia = charfreq[i];

    hn.izquierda = null;
    hn.right = null;

    // add functions adds
    // the huffman node to the queue.
    q.push(hn);
}

// create a root node
let root = null;
q.sort(function(a, b) { return a.frecuencia - b.frecuencia; });

// Here we will extract the two minimum value
// from the heap each time until
// its size reduces to 1, extract until
// all the nodes are extracted.
while (q.length > 1) {

    // first min extract.
    let x = q[0];
    q.shift();

    // second min extract.
    let y = q[0];
    q.shift();

    // new node f which is equal
    let f = new NodoHuffman();

    // to the sum of the frequency of the two nodes
    // assigning values to the f node.
    f.frecuencia = x.frecuencia + y.frecuencia;
    f.c = '-';

    // first extracted node as izquierda child.
    f.izquierda = x;

    // second extracted node as the right child.
    f.right = y;

    // marking the f node as the root node.
    root = f;

    // add this node to the priority-queue.
    q.push(f);
    q.sort(function(a, b) { return a.frecuencia - b.frecuencia; });
}

// print the codes by traversing the tree
printCode(root, "");

// This code is contributed by avanitrachhadiya2155